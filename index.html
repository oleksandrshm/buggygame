<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buggygame</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, buggy, terrain, controls, wheels = [];
        let moveForward = false, moveBackward = false, turnLeft = false, turnRight = false;
        let speed = 0.1;  // Початкова швидкість

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);  // Блакитне небо

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); 
        camera.position.set(0, 5, 15);  

        // Рендер
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);  
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);

        const terrainGeometry = new THREE.PlaneGeometry(500, 500, 64, 64); 
        const terrainMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22, wireframe: false }); 

        const positions = terrainGeometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const z = Math.random() * 10 - 5;  
            positions.setZ(i, z);
        }

        positions.needsUpdate = true;  
        terrainGeometry.computeVertexNormals();  
        terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = -2;  
        scene.add(terrain);

        const loader = new THREE.GLTFLoader();
        loader.load('https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/Buggy/glTF/Buggy.gltf', function(gltf) {
            buggy = gltf.scene;
            buggy.scale.set(0.1, 0.1, 0.1); 
            buggy.position.set(0, 1, 0); 
            scene.add(buggy);

            // Знаходимо колеса
            buggy.traverse(function(node) {
                if (node.isMesh && node.name.includes('Wheel')) {  
                    wheels.push(node);
                }
            });

            // Камера буде слідкувати за баггі
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target = buggy.position;
            controls.update();
        }, undefined, function(error) {
            console.error('Помилка завантаження моделі:', error);
        });

        // Керування автомобілем
        function handleKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                    turnLeft = true;
                    break;
                case 'ArrowRight':
                    turnRight = true;
                    break;
                case 'ShiftLeft':  
                    speed += 0.05; 
                    break;
                case 'ControlLeft':  
                    speed = Math.max(0.1, speed - 0.05);  
                    break;
            }
        }

        function handleKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                    turnLeft = false;
                    break;
                case 'ArrowRight':
                    turnRight = false;
                    break;
            }
        }

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);

        // Анімаційний цикл
        function animate() {
            requestAnimationFrame(animate);

            const turnSpeed = 0.05;
            const wheelRotationSpeed = 0.5;  

            if (buggy) {
                if (moveForward) {
                    buggy.translateZ(speed);

                    wheels.forEach(wheel => {
                        wheel.rotation.x -= wheelRotationSpeed;
                    });
                }

                if (moveBackward) {
                    buggy.translateZ(-speed);

                    wheels.forEach(wheel => {
                        wheel.rotation.x += wheelRotationSpeed;
                    });
                }

                if (turnLeft) {
                    buggy.rotation.y += turnSpeed;
                }

                if (turnRight) {
                    buggy.rotation.y -= turnSpeed;
                }

                controls.target.copy(buggy.position);
                controls.update();
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
